/**
 * Centralized HTTPS Agent for Microservice Communication
 *
 * This module provides a single, cached HTTPS agent for all microservice
 * communication. It handles certificate loading once at startup and
 * caches the agent in memory.
 *
 * IMPORTANT: This is the ONLY place certificate paths should be defined.
 * All routes should import from here instead of creating their own agents.
 */

const https = require('https');
const fs = require('fs');
const { createModuleLogger } = require('./logger');

const logger = createModuleLogger('HTTPS-AGENT');

// Possible CA certificate paths (in order of preference)
const CA_CERT_PATHS = [
  '/app/certs/ca.crt',           // Generated by generate-service-cert.sh
  '/app/certs/ca-cert.pem',      // Legacy path
  '/app/certs/ca.pem',           // Alternative
];

// Environment flag to allow insecure connections (development only)
const ALLOW_INSECURE_TLS = process.env.ALLOW_INSECURE_TLS === 'true';

// Log the flag on module load
logger.info(`HTTPS Agent module loaded. ALLOW_INSECURE_TLS=${ALLOW_INSECURE_TLS}`);

// Cached HTTPS agent - initialized once, used everywhere
let cachedHttpsAgent = null;
let agentInitialized = false;

/**
 * Find and load the CA certificate
 * @returns {Buffer|null} The CA certificate buffer or null if not found
 */
function loadCACertificate() {
  logger.info('Searching for CA certificate...');

  for (const certPath of CA_CERT_PATHS) {
    try {
      logger.debug(`Checking path: ${certPath}`);
      if (fs.existsSync(certPath)) {
        const cert = fs.readFileSync(certPath);
        logger.info(`✅ Loaded CA certificate from: ${certPath} (${cert.length} bytes)`);
        return cert;
      } else {
        logger.debug(`Path does not exist: ${certPath}`);
      }
    } catch (error) {
      logger.warn(`Error reading cert from ${certPath}: ${error.message}`);
    }
  }

  logger.warn('❌ No CA certificate found at any expected location', {
    searchedPaths: CA_CERT_PATHS
  });
  return null;
}

/**
 * Initialize the HTTPS agent
 * This should be called once at server startup
 */
function initializeHttpsAgent() {
  if (agentInitialized && cachedHttpsAgent) {
    logger.debug('HTTPS agent already initialized, returning cached agent');
    return cachedHttpsAgent;
  }

  logger.info('=== Initializing HTTPS Agent ===');
  logger.info(`ALLOW_INSECURE_TLS environment variable: ${process.env.ALLOW_INSECURE_TLS}`);
  logger.info(`ALLOW_INSECURE_TLS parsed value: ${ALLOW_INSECURE_TLS}`);

  const caCert = loadCACertificate();

  if (caCert) {
    // Production mode with proper CA verification
    cachedHttpsAgent = new https.Agent({
      ca: caCert,
      rejectUnauthorized: true,
      keepAlive: true,
      maxSockets: 50
    });
    logger.info('✅ HTTPS agent initialized with CA certificate verification');
  } else if (ALLOW_INSECURE_TLS) {
    // Development mode - skip verification (NOT FOR PRODUCTION)
    cachedHttpsAgent = new https.Agent({
      rejectUnauthorized: false,
      keepAlive: true,
      maxSockets: 50
    });
    logger.warn('⚠️  HTTPS agent initialized WITHOUT certificate verification (ALLOW_INSECURE_TLS=true)');
    logger.warn('⚠️  This is INSECURE and should only be used in development');
  } else {
    // No certs and not allowing insecure - default to insecure with warning
    // This is a fallback for docker internal networks
    cachedHttpsAgent = new https.Agent({
      rejectUnauthorized: false,
      keepAlive: true,
      maxSockets: 50
    });
    logger.warn('⚠️  No CA certificate found and ALLOW_INSECURE_TLS not set');
    logger.warn('⚠️  Defaulting to unverified HTTPS for internal docker network');
    logger.warn('⚠️  For production, ensure certificates are properly mounted at /app/certs');
  }

  agentInitialized = true;
  logger.info(`=== HTTPS Agent Ready (rejectUnauthorized=${cachedHttpsAgent.options.rejectUnauthorized}) ===`);
  return cachedHttpsAgent;
}

/**
 * Get the cached HTTPS agent
 * Initializes on first call if not already initialized
 * @returns {https.Agent} The HTTPS agent for microservice calls
 */
function getHttpsAgent() {
  if (!agentInitialized || !cachedHttpsAgent) {
    return initializeHttpsAgent();
  }
  return cachedHttpsAgent;
}

/**
 * Force reinitialize the HTTPS agent
 * Useful if certificates are updated at runtime
 */
function reinitializeHttpsAgent() {
  logger.info('Force reinitializing HTTPS agent...');
  agentInitialized = false;
  cachedHttpsAgent = null;
  return initializeHttpsAgent();
}

/**
 * Check if TLS verification is enabled
 * @returns {boolean} True if proper CA verification is active
 */
function isTlsVerificationEnabled() {
  const agent = getHttpsAgent();
  return agent && agent.options && agent.options.rejectUnauthorized === true;
}

module.exports = {
  getHttpsAgent,
  initializeHttpsAgent,
  reinitializeHttpsAgent,
  isTlsVerificationEnabled,
  ALLOW_INSECURE_TLS
};

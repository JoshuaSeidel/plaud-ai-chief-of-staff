# AI Chief of Staff - Cursor Instructions

## Application Overview

AI Chief of Staff is an intelligent executive assistant application that automates personal productivity by:

- **Ingesting meeting transcripts** and using Claude AI to extract actionable items
- **Generating daily briefs** with priorities, deliverables, and commitments
- **Tracking commitments, actions, follow-ups, and risks** in a unified task system
- **Integrating with Google Calendar** for automatic event creation
- **Providing push notifications** for task reminders and overdue alerts
- **Supporting offline mode** with background sync when connection is restored

## Architecture & Design

### Tech Stack
- **Frontend**: React 18 with modern hooks, React Router, Axios, React Markdown
- **Backend**: Node.js with Express
- **Database**: SQLite (default) or PostgreSQL with unified interface
- **AI**: Anthropic Claude API (claude-3-5-sonnet, claude-sonnet-4.5, etc.)
- **Deployment**: Single all-in-one Docker container

### Project Structure
```
/
├── backend/          # Node.js/Express backend
│   ├── config/      # Configuration management and default prompts
│   ├── database/    # Database abstraction layer (SQLite/PostgreSQL)
│   ├── routes/      # API route handlers
│   ├── services/    # Business logic (AI, calendar, notifications, etc.)
│   └── utils/       # Utilities (logging, etc.)
├── frontend/        # React frontend
│   ├── src/
│   │   ├── components/  # React components (Dashboard, Tasks, Calendar, etc.)
│   │   ├── services/    # API service layer
│   │   └── utils/       # Frontend utilities (offline storage, etc.)
│   └── public/      # Static assets and service worker
└── Dockerfile       # All-in-one container build
```

### Key Design Principles

1. **Single Container Deployment**: Everything runs in one Docker container for easy deployment on Unraid or any Docker host
2. **Progressive Web App (PWA)**: Installable, works offline, supports push notifications
3. **Configuration via UI**: All settings (API keys, database, prompts) configured through web UI, stored in `/app/data/config.json`
4. **Dual Database Support**: Seamless switching between SQLite and PostgreSQL
5. **AI-Driven Extraction**: Uses Claude AI to extract tasks, commitments, and generate insights from transcripts
6. **Offline-First**: Tasks can be created offline and sync when connection is restored

### Core Features

#### Dashboard
- Morning Dashboard: AI-generated daily brief with top priorities, deliverables, and commitments
- Quick Actions: Navigation buttons to Tasks, Transcripts, Calendar, and Settings
- Brief generation uses Claude AI to analyze all transcripts and commitments

#### Task Management
- Unified system for: Commitments, Actions, Follow-ups, Risks
- Color-coded status badges (On Track, At Risk, Behind)
- Smart deadline assignment (default 2 weeks)
- Filtering by type, status, and date

#### Transcript Processing
- Upload transcripts (.txt, .doc, .docx, .pdf) or paste text
- AI extracts: commitments, actions, follow-ups, risks
- Automatic deadline assignment and calendar event creation

#### Calendar Integration
- Google Calendar OAuth integration
- Auto-creates events for commitments with deadlines
- Rich event descriptions (3-5 paragraphs) generated by AI
- Two-way sync: view calendar events, create events for tasks

#### Notifications
- Push notifications for task reminders (24 hours before deadline)
- Daily overdue task alerts
- Background task scheduler runs every 30 minutes

#### AI Customization
- All AI prompts editable via UI (Prompts tab)
- Template variables: `{{transcriptText}}`, `{{taskType}}`, `{{dateContext}}`, etc.
- Changes apply immediately without restart

## Code Quality & Standards

### ESLint Requirements

**CRITICAL**: ESLint runs automatically on every build and MUST pass with zero warnings.

- ESLint is configured via `react-app` preset in `frontend/package.json`
- The build process (`npm run build`) runs ESLint automatically with `--max-warnings=0`
- **Maximum warnings: 0** - Any ESLint warnings will cause the build to fail
- The Docker build process runs `npm run build` which includes ESLint, so all commits with JS changes will be checked
- **Note**: Pre-commit hooks may be configured but the build process is the primary enforcement mechanism

### ESLint Rules
- No unused variables or functions
- React hooks must follow exhaustive-deps rules (use `eslint-disable-line` comments only when necessary)
- Follow React best practices
- Use proper error handling

### Before Committing JavaScript Changes

1. **Bump version if needed** (unless it's a minor bug fix):
   ```bash
   node scripts/bump-version.js
   ```

2. **Always run ESLint locally** before committing:
   ```bash
   cd frontend
   npm run build  # This runs ESLint automatically
   ```

3. **Fix all warnings** - The build will fail if there are any warnings

4. **Check for unused code** - Remove unused functions, variables, imports

5. **Verify the build succeeds** - The Docker build process runs `npm run build` which includes ESLint

### Common ESLint Issues to Avoid

- Unused variables or functions (like `handleGenerateWeeklyReport` that was recently removed)
- Missing dependencies in useEffect hooks
- Unused imports
- Console.log statements in production code (use proper logging)

## Version Management

### Version Bumping Requirements

**CRITICAL**: Bump the version number before each push, UNLESS it's a minor bug fix.

- Version is stored in both `backend/package.json` and `frontend/package.json`
- Both files must have the same version number
- Use the version bump script: `node scripts/bump-version.js`
- This increments the patch version (e.g., 1.0.0 -> 1.0.1)

### When to Bump Version

**Bump version for:**
- New features
- Significant changes or improvements
- UI/UX enhancements
- New integrations or functionality
- Breaking changes (should also bump major or minor version manually)

**Do NOT bump version for:**
- Minor bug fixes (typos, small CSS tweaks, etc.)
- Documentation-only changes
- ESLint fixes that don't change functionality
- Code cleanup that doesn't affect behavior

### How to Bump Version

1. **Run the bump script:**
   ```bash
   node scripts/bump-version.js
   ```

2. **Verify both package.json files were updated:**
   - `backend/package.json`
   - `frontend/package.json`
   - Both should show the same new version

3. **Commit the version changes along with your code changes:**
   ```bash
   git add backend/package.json frontend/package.json
   git commit -m "Your commit message"
   ```

### Manual Version Bumping

If you need to bump major or minor version (not just patch), manually edit both package.json files:
- Major version: 1.0.0 -> 2.0.0 (breaking changes)
- Minor version: 1.0.0 -> 1.1.0 (new features, backward compatible)
- Patch version: 1.0.0 -> 1.0.1 (use the script for this)

## Development Guidelines

### Frontend Development
- Use functional components with hooks
- Keep components focused and reusable
- Use the API service layer (`services/api.js`) for all backend communication
- Handle offline scenarios gracefully
- Use proper error boundaries and loading states

### Backend Development
- All configuration stored in `/app/data/config.json`
- Use the database abstraction layer (`database/db.js`) for all DB operations
- Services should be modular and testable
- Use the logger utility for all logging

### Database
- Support both SQLite and PostgreSQL
- Use the unified database interface - don't write SQL directly
- Database type is determined at startup from config

### AI Integration
- All AI prompts are configurable via UI
- Default prompts stored in `backend/config/default-prompts.js`
- Use the AI service (`services/ai-service.js`) for all Claude API calls

### Styling Convention

#### CSS Architecture
- **USE CSS CLASSES ONLY** - No inline styles in JSX components (except for truly dynamic values like transform calculations, animation delays, or conditional colors based on runtime data)
- All styling belongs in `frontend/src/index.css`
- Build reusable utility classes for common patterns before writing new styles
- Check existing CSS classes before creating new ones - we have 100+ utility classes available

#### Allowed Inline Styles (Exceptions Only)
- Dynamic transforms: `style={{ transform: 'translateY(...)' }}`
- Animation delays: `style={{ animationDelay: '0.5s' }}`
- Progress percentages: `style={{ width: '${progress}%' }}`
- Conditional colors from API data: `style={{ backgroundColor: statusColor }}`
- **DO NOT** use inline styles for static layouts, spacing, typography, or anything that can be a CSS class

#### CSS Class Naming
- Semantic names: `.task-card`, `.brief-content`, `.insights-widget`
- Component-specific: `.transcript-table-row`, `.deliverables-table`
- Utility classes: `.flex`, `.gap-md`, `.mt-lg`, `.text-center`
- State variants: `.btn-primary`, `.btn-secondary`, `.message-error`, `.message-success`
- Markdown elements: `.md-h1`, `.md-h2`, `.md-h3`, `.md-strong`, `.md-em`, `.md-list`, `.md-li`, `.md-p`, `.md-table`

#### Mobile-First Responsive Design
- Base styles for mobile (min 320px width)
- Desktop styles in `@media (min-width: 769px)` queries
- Touch targets minimum 44px for iOS (Apple HIG)
- Font-size minimum 16px on inputs to prevent iOS zoom
- Test on both mobile and desktop viewports

#### CSS Quality Rules
- **NEVER** use `!important` - fix specificity instead
- **NEVER** use attribute selectors like `input[type="text"]` - use classes
- Prefer flexbox and grid for layouts
- Use CSS custom properties for theme colors (when implemented)
- Keep specificity low - avoid deep nesting
- Group related styles together in index.css with comments
- Dark theme throughout (#1a1a1a background, #27272a cards)

#### Before Writing New Styles
1. Check if a utility class already exists (`.flex`, `.gap-*`, `.mt-*`, `.mb-*`, `.text-*`)
2. Check if a component class exists (`.task-card`, `.form-box`, `.stat-box`)
3. If creating new classes, make them reusable across components
4. Add clear section comments in index.css for discoverability

## Important Notes

1. **Never commit API keys** - All keys configured via UI
2. **Data persistence** - All data stored in `/app/data` which should be mounted as a volume
3. **Version injection** - Version is injected at build time into service worker
4. **PWA features** - Service worker handles offline functionality and caching
5. **Docker build** - Frontend is built in Docker, then copied to backend's public directory

## Testing Before Deployment

1. Run ESLint: `cd frontend && npm run build`
2. Test Docker build: `docker build -t ai-chief-of-staff .`
3. Verify all features work: transcripts, brief generation, calendar, tasks
4. Test offline functionality
5. Verify push notifications (if configured)

## Deployment

- Single Docker container deployment
- Port 3001 (configurable via PORT env var)
- Volumes: `/app/data` (config and database), `/app/uploads` (transcripts)
- Health check endpoint: `/api/health`

